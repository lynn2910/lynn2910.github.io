import{_ as n}from"./project_view.css_vue_type_style_index_0_src_true_lang-BZ5tudZz.js";import{d as a,e as t,w as i,o as u,a as e,g as s}from"./index-DonNLUZR.js";const r=e("h1",{id:"top"},"Le projet 'Calco'",-1),o=e("p",null,"Ce projet est une mini-expérimentation du développement d'un langage destiné aux expressions mathématiques.",-1),p=e("h2",{id:"parsing"},"Comment lire une expression mathématique?",-1),c=e("div",{class:"h2"},[e("p",null,"Une expression mathématique peut être aussi simple que:"),e("pre",{class:"full"},"1 + 1 * 5 - (9 * 9 + 1)"),e("p",null,"Dans ce cas, nous pouvons dire que le calcul serait alors:"),e("pre",{class:"full"},"1 + ( 1 * 5 ) - ((9 * 9) + 1)"),e("p",null,"Prenons le temps de décortiquer les calculs effectués:"),e("ul",null,[e("li",null,[e("p",null,[e("strong",null,[e("code",null,"1 + (1 * 5)"),s(":")])]),e("p",null,[s("D'après les lois des mathématiques, l'opération "),e("code",null,"1 * 5"),s(" est prioritaire, avec ou sans les parenthèses. Et on calcule ensuite: "),e("code",null,"1 + [result]")]),e("p",null,[s("Le résultat final est alors: "),e("code",null,"6")])]),e("li",null,[e("p",null,[e("strong",null,[e("code",null,"6 - ((9 * 9) + 1)")])]),e("p",null,"Cette fois l'expression est plus costaud, mais la logique est la même."),e("p",null,[s("Nous allons d'abord calculer "),e("code",null,"9 * 9"),s(", puis "),e("code",null,"[result] + 1")]),e("p",null,[s("Au final, nous avons "),e("code",null,"6 - 82 = -76")])])]),e("p",null,"Vous aurez peut être remarqué le caractère récursif de la logique derrière."),e("p",null,"Je vais suivre la même logique en utilisant un arbre binaire, car en effet, on aura toujours que deux cotés dans un calcul.")],-1),d=e("h2",{id:"tokenization"},"La 'tokenisation'",-1),m=e("div",{class:"h2"},[e("p",null,"La tokenisation est le processus d'interpretation de l'expression par un algorithme autonome qui va alors préparer le travail."),e("p",null,"Pour ce calcul:"),e("pre",{class:"full"},"1 + 5 - (8 + 6)"),e("p",null,"Nous aurons alors la liste de tokens suivants:"),e("pre",{class:"full"},[e("code",null,"[Number(1), Plus, Number(5), Minus, ParenthesisOpen, Number(8), Plus, Number(6), ParenthesisClose]")]),e("p",null,"Cette liste de tokens nous permettra alors de faire plusieurs choses:"),e("ul",null,[e("li",null,"Vérifier la syntaxe. Nous pouvons immédiatement savoir si une parenthèse a été oubliée ou si deux nombres sont voisins mais qu'il n'y a pas une opération."),e("li",null,"Créer l'arbre binaire (AST)"),e("li",null,"Optimiser le calcul. (voir plus loin)")]),e("h3",{id:"optimize"},"Optimiser l'expression"),e("div",{class:"h3"},[e("p",null,"Dans le cas d'expression mathématiques aussi simple, on peut juste calculer le résultat final. Cependant, ce qui est intéressant, c'est quand nous avons des équations avec variables. Prenons cet exemple:"),e("pre",{class:"full"},"3x^(1 + 1) + x - (2 - 1)"),e("p",null,'Dans ce cas, on peut "optimiser" les opérations entre deux entiers ou qui ne dépendent pas de variables, ce qui donnera finalement:'),e("pre",{class:"full"},"3x^2 + x - 1"),e("p",null,"Ce cas n'est pas un exemple concret car l'équation est très facile, cependant cela pourrait aussi fonctionner avec des équations plus complexes.")])],-1),h=e("h2",{id:"ast"},"L'arbre de syntaxe abstrait (AST)",-1),v=e("div",{class:"h2"},[e("p",null,"Maintenant que nous avons vu comment définir une liste de tokens à partir de l'expression mathématique, on peut alors générer un arbre binaire."),e("p",null,"Cette arbre binaire partira de la première expression à calculer à gauche, et à droite, on descendra récursivement dans l'arbre pour calculer le résultat final.")],-1),C=a({__name:"CalcoProject",setup(x){const l=[{name:"Le projet 'Calco'",id:"top",level:1},{name:"Comment lire une expression mathématique?",id:"parsing",level:2},{name:"La 'tokenisation'",id:"tokenization",level:2},{name:"Optimiser l'expression",id:"optimize",level:3},{name:"L'arbre de syntaxe abstrait (AST)",id:"ast",level:2}];return(f,_)=>(u(),t(n,{headers:l,title:"Calco"},{default:i(()=>[r,o,p,c,d,m,h,v]),_:1}))}});export{C as default};
